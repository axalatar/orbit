<html>
   <head>
      <title>Orbit</title>
   </head>
   <body style="margin:0">
      <!-- help from https://codelabs.developers.google.com/your-first-webgpu-app -->
      <canvas id = "canvas"></canvas>
      <div id="error"></div>
      <script type="module">
         var canvas = document.getElementById('canvas');
         var errorDiv = document.getElementById('error');
         
         if(!navigator.gpu) {
            error.innerHTML = "WebGPU is not supported on this browser ); try looking at one of these: https://caniuse.com/webgpu"
            throw Error("WebGPU is not supported on this browser ); try looking at one of these: https://caniuse.com/webgpu")
         }

         const adapter = await navigator.gpu.requestAdapter();

         if(!adapter) {
            error.innerHTML = "No appropriate GPUAdapter found ); maybe try looking at one of these?: https://caniuse.com/webgpu"
            throw Error("WebGPU is not supported on this browser ); try looking at one of these: https://caniuse.com/webgpu")
         }

         canvas.width = window.innerWidth;
         canvas.height = window.innerHeight;

         const device = await adapter.requestDevice();

         const ctx = canvas.getContext("webgpu");
         const canvasFormat = navigator.gpu.getPreferredCanvasFormat();


         const G = 0.001;
         const colorScale = 0.1;

         ctx.configure({
            device: device,
            format: canvasFormat
         })

         const vertices = new Float32Array([
            0.5, 0.5,
            -0.5, 0.5,
            0.5, -0.5,
            -0.5, -0.5,
         ])

         const vertexBuffer = device.createBuffer({
            label: "Body vertices",
            size: vertices.byteLength,
            usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST
         })

         device.queue.writeBuffer(vertexBuffer, 0, vertices);

         const gravityUniform = new Float32Array([G]);
         const uniformBuffer = device.createBuffer({
            label: "Gravity Uniform",
            size: gravityUniform.byteLength,
            usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
         });

         device.queue.writeBuffer(uniformBuffer, 0, gravityUniform);
         
         const vertexBufferLayout = {
            arrayStride: 8,
            attributes: [{
               format: "float32x2",
               offset: 0,
               shaderLocation: 0
            }]
         }


         const velocitiesStateArray = new Float32Array(vertices.length*3);

         const velocitiesStateStorage = device.createBuffer({
            label: "Velocities State",
            size: velocitiesStateArray.byteLength,
            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
         });

         // for (let i = 0; i < velocitiesStateArray.length*3; i++) {
            // velocitiesStateArray[i] = 0;
         // }

         for (let i = 0; i < velocitiesStateArray.length; i++) {
            velocitiesStateArray[i] = i;
         }
         
         // let wantedVelocities = [
         //    [1, 1, 1],
         //    [0, 0, 0],
         //    [1, 2, 3],
         //    [3, 2, 1]
         // ]
         // for(let i = 0; i < wantedVelocities.length; i++) {
         //    velocitiesStateArray[i*3] = wantedVelocities[i][0];
         //    velocitiesStateArray[i*3 + 1] = wantedVelocities[i][1];
         //    velocitiesStateArray[i*3 + 2] = wantedVelocities[i][2];
         // }
         
         device.queue.writeBuffer(velocitiesStateStorage, 0, velocitiesStateArray);

         const bodyShaderModule = device.createShaderModule({
            label: "Body shader",
            code: `
               @group(0) @binding(0) var<uniform> G: f32;
               @group(0) @binding(1) var<storage> velocities: array<f32>;

               struct VertexOutput {
                  @builtin(position) pos: vec4f,
                  @location(0) color: f32
               };

               @vertex
               fn vertexMain(@location(0) pos: vec2f, @builtin(instance_index) instance: u32) -> VertexOutput {
               
                  var output: VertexOutput;

                  output.pos = vec4f(pos, 0, 1);
                  output.color = velocities[instance];
                  return output;
               }

               @fragment
               fn fragmentMain(@location(0) color: f32) -> @location(0) vec4f {
                  return vec4f(1, color, G*0, 1);
               }
            `
         });

         const bodyPipeline = device.createRenderPipeline({
            label: "Body pipeline",
            layout: "auto",
            vertex: {
               module: bodyShaderModule,
               entryPoint: "vertexMain",
               buffers: [vertexBufferLayout]
            },
            fragment: {
               module: bodyShaderModule,
               entryPoint: "fragmentMain",
               targets: [{
                  format: canvasFormat
               }]
            },
            primitive: {
               topology: 'point-list',
            }
         })

         const bindGroup = device.createBindGroup({
            label: "Body renderer bind group",
            layout: bodyPipeline.getBindGroupLayout(0),
            entries: [
               {
                  binding: 0,
                  resource: { buffer: uniformBuffer }
               },
               {
                  binding: 1,
                  resource: { buffer: velocitiesStateStorage }
               }
         ]
         });

         const encoder = device.createCommandEncoder();
         const pass = encoder.beginRenderPass({
            colorAttachments: [{
               view: ctx.getCurrentTexture().createView(),
               loadOp: "clear",
               storeOp: "store"
            }]
         })

         pass.setPipeline(bodyPipeline);
         pass.setVertexBuffer(0, vertexBuffer);

         pass.setBindGroup(0, bindGroup);

         pass.draw(vertices.length / 2);

         pass.end()

         device.queue.submit([encoder.finish()])
      </script>
   </body>
</html>