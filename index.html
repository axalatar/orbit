<html>
   <head>
      <title>Orbit</title>
   </head>
   <body style="margin:0">
      <!-- help from https://codelabs.developers.google.com/your-first-webgpu-app -->
      <canvas id = "canvas"></canvas>
      <div id="error"></div>
      <script type="module">
         var canvas = document.getElementById('canvas');
         var errorDiv = document.getElementById('error');
         
         if(!navigator.gpu) {
            error.innerHTML = "WebGPU is not supported on this browser ); try looking at one of these: https://caniuse.com/webgpu"
            throw Error("WebGPU is not supported on this browser ); try looking at one of these: https://caniuse.com/webgpu")
         }

         const adapter = await navigator.gpu.requestAdapter();

         if(!adapter) {
            error.innerHTML = "No appropriate GPUAdapter found ); maybe try looking at one of these?: https://caniuse.com/webgpu"
            throw Error("WebGPU is not supported on this browser ); try looking at one of these: https://caniuse.com/webgpu")
         }

         canvas.width = window.innerWidth;
         canvas.height = window.innerHeight;

         const device = await adapter.requestDevice();

         const ctx = canvas.getContext("webgpu");
         const canvasFormat = navigator.gpu.getPreferredCanvasFormat();


         const G = 0.001;

         ctx.configure({
            device: device,
            format: canvasFormat
         })

         const vertices = new Float32Array([
            0.5, 0.5,
            -0.5, 0.5,
            -0.5, -0.5,

            -0.5, -0.5,
            0.5, -0.5,
            0.5, 0.5
         ])

         const vertexBuffer = device.createBuffer({
            label: "Body vertices",
            size: vertices.byteLength,
            usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST
         })

         device.queue.writeBuffer(vertexBuffer, 0, vertices);

         
         const vertexBufferLayout = {
            arrayStride: 8,
            attributes: [{
               format: "float32x2",
               offset: 0,
               shaderLocation: 0
            }]
         }

         const bodyShaderModule = device.createShaderModule({
            label: "Body shader",
            code: `
               @vertex
               fn vertexMain(@location(0) pos: vec2f) -> @builtin(position) vec4f {
                  return vec4f(pos, 0, 1);
               }

               @fragment
               fn fragmentMain() -> @location(0) vec4f {
                  return vec4f(1, 0, 0, 1);
               }
            `
         });

         const bodyPipeline = device.createRenderPipeline({
            lable: "Body pipeline",
            layout: "auto",
            vertex: {
               module: bodyShaderModule,
               entryPoint: "vertexMain",
               buffers: [vertexBufferLayout]
            },
            fragment: {
               module: bodyShaderModule,
               entryPoint: "fragmentMain",
               targets: [{
                  format: canvasFormat
               }]
            },
            primitive: {
               topology: 'point-list',
            }
         })

         const encoder = device.createCommandEncoder();
         const pass = encoder.beginRenderPass({
            colorAttachments: [{
               view: ctx.getCurrentTexture().createView(),
               loadOp: "clear",
               storeOp: "store"
            }]
         })

         pass.setPipeline(bodyPipeline);
         pass.setVertexBuffer(0, vertexBuffer);
         pass.draw(vertices.length / 2);

         pass.end()

         device.queue.submit([encoder.finish()])
      </script>
   </body>
</html>